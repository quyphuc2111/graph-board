/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Board.js":
/*!**********************!*\
  !*** ./src/Board.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Position */ \"./src/Position.js\");\n\n\nclass Board {\n\tconstructor({ width, height, radius, fontSize }) {\n\t\tthis.canvas = document.createElement(\"canvas\");\n\t\tthis.context = this.canvas.getContext(\"2d\");\n\t\tthis.radius = radius || 20;\n\t\tthis.fontSize = fontSize || 25;\n\t\tthis.clientPosition = { x: 0, y: 0 };\n\t\tthis.prevPosition = { x: 0, y: 0 };\n\t\tthis.buttons = 0;\n\t\tthis.shift = false;\n\t\tthis.alt = false;\n\t\tthis.selector = \"\";\n\t\tthis.position = new _Position__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n\n\t\tthis.canvas.width = width || 300;\n\t\tthis.canvas.height = height || 400;\n\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.canvas.onmousemove = (event) => {\n\t\t\tthis.prevPosition = { ...this.clientPosition };\n\t\t\tthis.clientPosition = {\n\t\t\t\tx: event.clientX - this.canvas.offsetLeft + window.scrollX,\n\t\t\t\ty: event.clientY - this.canvas.offsetTop + window.scrollY,\n\t\t\t};\n\t\t\tthis.buttons = event.buttons;\n\t\t\tthis.shift = event.shiftKey;\n\t\t\tthis.alt = event.altKey;\n\t\t};\n\t\twindow.onresize = () => {\n\t\t\tif (this.selector) this.appendTo(this.selector);\n\t\t};\n\t}\n\tappendTo(selector) {\n\t\tthis.selector = selector;\n\t\tconst parent = document.querySelector(selector);\n\t\tparent.innerHTML = \"\";\n\t\tparent.append(this.canvas);\n\t\tthis.canvas.width = parent.offsetWidth;\n\t\tthis.canvas.height = parent.offsetHeight;\n\t}\n\tdrawCircle(x, y, r) {\n\t\tthis.context.lineWidth = 5;\n\t\tthis.context.beginPath();\n\t\tthis.context.arc(x, y, r, 0, 2 * Math.PI);\n\t\tthis.context.stroke();\n\t\tthis.context.fillStyle = \"#fff\";\n\t\tthis.context.fill();\n\t\tthis.context.fillStyle = \"#000\";\n\t\tthis.context.lineWidth = 1;\n\t}\n\tdrawNode(x, y, u, active) {\n\t\tif (active) this.context.strokeStyle = \"#dc3545\";\n\t\tthis.drawCircle(x, y, this.radius);\n\t\tthis.context.font = `${this.fontSize}px Arial`;\n\t\tthis.context.textAlign = \"center\";\n\t\tthis.context.fillText(u, x, y + this.fontSize / 2);\n\t\tthis.context.strokeStyle = \"#000\";\n\t}\n\tdrawMotionLine(x1, y1, x2, y2, color) {\n\t\tthis.context.lineWidth = 5;\n\t\tthis.context.strokeStyle = color || \"orange\";\n\t\tthis.context.beginPath();\n\t\tthis.context.moveTo(x1, y1);\n\t\tthis.context.lineTo(x2, y2);\n\t\tthis.context.stroke();\n\t\tthis.context.lineWidth = 1;\n\t\tthis.context.strokeStyle = \"#000\";\n\t}\n\tdrawLine(x1, y1, x2, y2) {\n\t\tthis.context.lineWidth = 2;\n\t\tthis.context.beginPath();\n\t\tthis.context.moveTo(x1, y1);\n\t\tthis.context.lineTo(x2, y2);\n\t\tthis.context.stroke();\n\t\tthis.context.lineWidth = 1;\n\t}\n\tdrawDirected(x1, y1, x2, y2, distance) {\n\t\tconst curvePos = this.getCurvePos(x1, y1, x2, y2, distance);\n\t\tconst angle = Math.atan2(curvePos.y - y2, curvePos.x - x2);\n\t\tconst A = {\n\t\t\tx: x2 + this.radius * Math.cos(angle),\n\t\t\ty: y2 + this.radius * Math.sin(angle),\n\t\t};\n\t\tconst M = {\n\t\t\tx: A.x + (this.radius * Math.cos(angle) * Math.pow(3, 1 / 2)) / 2,\n\t\t\ty: A.y + (this.radius * Math.sin(angle) * Math.pow(3, 1 / 2)) / 2,\n\t\t};\n\t\tconst B = {\n\t\t\tx: M.x + (this.radius / 2) * Math.cos(angle - Math.PI / 2),\n\t\t\ty: M.y + (this.radius / 2) * Math.sin(angle - Math.PI / 2),\n\t\t};\n\n\t\tconst C = {\n\t\t\tx: M.x + (this.radius / 2) * Math.cos(angle + Math.PI / 2),\n\t\t\ty: M.y + (this.radius / 2) * Math.sin(angle + Math.PI / 2),\n\t\t};\n\n\t\tthis.context.lineWidth = 5;\n\t\tthis.context.beginPath();\n\t\tthis.context.moveTo(A.x, A.y);\n\t\tthis.context.lineTo(B.x, B.y);\n\t\tthis.context.lineTo(C.x, C.y);\n\t\tthis.context.lineTo(A.x, A.y);\n\t\tthis.context.fillStyle = \"#000\";\n\t\tthis.context.stroke();\n\t\tthis.context.fill();\n\t\tthis.context.lineWidth = 1;\n\t}\n\n\tdrawDistance(x1, y1, x2, y2, distance, fill) {\n\t\tconst d = this.getDistance(new _Position__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x1, y1), new _Position__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x2, y2));\n\t\tconst curvePos = this.getCurvePos(x1, y1, x2, y2, distance);\n\n\t\tthis.context.fillStyle = fill || \"#000\";\n\t\tthis.context.beginPath();\n\t\tthis.context.fillText(parseInt(d / 100), curvePos.x, curvePos.y);\n\t\tthis.context.textAlign = \"center\";\n\t\tthis.context.fillStyle = \"#fff\";\n\t}\n\n\tdrawHorizontal(y) {\n\t\tthis.context.strokeStyle = \"#fff\";\n\t\tthis.context.beginPath();\n\t\tthis.context.moveTo(0, y);\n\t\tthis.context.lineTo(this.canvas.width, y);\n\t\tthis.context.stroke();\n\t\tthis.context.strokeStyle = \"#000\";\n\t}\n\tdrawVertical(x) {\n\t\tthis.context.strokeStyle = \"#fff\";\n\t\tthis.context.beginPath();\n\t\tthis.context.moveTo(x, 0);\n\t\tthis.context.lineTo(x, this.canvas.height);\n\t\tthis.context.stroke();\n\t\tthis.context.strokeStyle = \"#000\";\n\t}\n\tdrawGrid() {\n\t\tfor (let i = 0; i <= this.canvas.height; i += this.radius * 2)\n\t\t\tthis.drawHorizontal(i);\n\t\tfor (let i = 0; i <= this.canvas.width; i += this.radius * 2)\n\t\t\tthis.drawVertical(i);\n\t}\n\tdrawCurve(x1, y1, x2, y2, distance) {\n\t\tthis.context.moveTo(x1, y1);\n\t\tconst curvePos = this.getCurvePos(x1, y1, x2, y2, distance);\n\n\t\tthis.context.quadraticCurveTo(curvePos.x, curvePos.y, x2, y2);\n\t\tthis.context.stroke();\n\t}\n\n\tgetMiddle(x1, y1, x2, y2) {\n\t\treturn this.position.getMiddle(x1, y1, x2, y2);\n\t}\n\n\tgetCurvePos(x1, y1, x2, y2, distance) {\n\t\treturn this.position.getCurvePos(x1, y1, x2, y2, distance);\n\t}\n\tgetDistance(pos1, pos2) {\n\t\treturn this.position.getDistance(pos1, pos2);\n\t}\n\tclear() {\n\t\tthis.context.fillStyle = \"#f4f8ff\";\n\t\tthis.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.context.fill();\n\t\tthis.context.fillStyle = \"#000\";\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Board);\n\n\n//# sourceURL=webpack://graph-board/./src/Board.js?");

/***/ }),

/***/ "./src/Graph.js":
/*!**********************!*\
  !*** ./src/Graph.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Board */ \"./src/Board.js\");\n/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queue */ \"./src/Queue.js\");\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ \"./src/Stack.js\");\n/* harmony import */ var _Tarjan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tarjan */ \"./src/Tarjan.js\");\n\n\n\n\n\nclass Graph {\n\tconstructor({\n\t\tdirected,\n\t\tshowDistance,\n\t\tshowGrid,\n\t\tradius,\n\t\tcharacter,\n\t\tmotion,\n\t} = {}) {\n\t\tthis.alphabet = \"_ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\t\tthis.board = new _Board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ radius });\n\t\tthis.nodes = [];\n\t\tthis.edges = [];\n\t\tthis.target = null;\n\t\tthis.selectedEdgeId = null;\n\t\tthis.directed = directed;\n\t\tthis.showDistance = showDistance;\n\t\tthis.showGrid = showGrid;\n\t\tthis.character = character;\n\t\tthis.motionSteps = { step: 0, steps: [] };\n\t\tthis.onchange = Function;\n\t\tthis.motion = motion;\n\t\tthis.linkedParts = [];\n\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.board.canvas.ondblclick = () => {\n\t\t\tif (this.target) return;\n\t\t\tthis.addNode(\n\t\t\t\tthis.nodes.length + 1,\n\t\t\t\tthis.board.clientPosition.x,\n\t\t\t\tthis.board.clientPosition.y\n\t\t\t);\n\t\t};\n\n\t\tthis.board.canvas.addEventListener(\"mousemove\", () => {\n\t\t\tconst { x, y } = this.board.clientPosition;\n\t\t\tdocument.body.style.cursor = \"unset\";\n\n\t\t\tthis.edges.map((edge, index) => {\n\t\t\t\tif (this.board.buttons === 1) return;\n\t\t\t\tconst from = this.nodes[edge.from - 1];\n\t\t\t\tconst to = this.nodes[edge.to - 1];\n\n\t\t\t\tif (!from || !to) return;\n\n\t\t\t\tconst curvePos = this.board.getCurvePos(\n\t\t\t\t\tfrom.x,\n\t\t\t\t\tfrom.y,\n\t\t\t\t\tto.x,\n\t\t\t\t\tto.y,\n\t\t\t\t\tedge.curve / 2\n\t\t\t\t);\n\t\t\t\tconst distance = this.board.getDistance(curvePos, { x, y });\n\n\t\t\t\tif (distance < this.board.radius) this.selectedEdgeId = index;\n\t\t\t\tif (this.target) this.selectedEdgeId = null;\n\t\t\t});\n\n\t\t\tthis.nodes.forEach((e) => {\n\t\t\t\tif (this.equalPoint(x, e.x) && this.equalPoint(y, e.y))\n\t\t\t\t\tthis.target = this.target || e.label;\n\t\t\t});\n\n\t\t\tif (!this.target) return;\n\t\t\tif (this.board.buttons && this.board.shift)\n\t\t\t\tdocument.body.style.cursor = \"move\";\n\t\t\telse document.body.style.cursor = \"pointer\";\n\t\t\tif (this.board.shift || this.board.buttons === 1) return;\n\t\t\tif (\n\t\t\t\t!this.equalPoint(x, this.target.x) ||\n\t\t\t\t!this.equalPoint(y, this.target, y)\n\t\t\t)\n\t\t\t\tthis.target = null;\n\t\t});\n\n\t\tthis.board.canvas.onclick = (event) => {\n\t\t\tif (!event.altKey) return;\n\t\t\tthis.removeEdge(this.edges[this.selectedEdgeId] || {});\n\t\t\tif (!this.target) return;\n\t\t\tthis.removeNode(this.nodes.length);\n\t\t};\n\n\t\tthis.render();\n\t}\n\n\trender() {\n\t\tthis.update();\n\t\tthis.draw();\n\t\tsetTimeout(() => {\n\t\t\tthis.render();\n\t\t}, 1000 / 60);\n\t}\n\n\tupdate() {\n\t\tthis.checkAddEdge();\n\t\tthis.updateCurve();\n\t\tthis.updateNodes();\n\t\tthis.updateMotion();\n\t}\n\tdraw() {\n\t\tthis.board.clear();\n\t\tif (this.showGrid) this.board.drawGrid();\n\t\tthis.drawEdges();\n\t\tthis.drawLine();\n\t\tthis.drawNodes();\n\t\tthis.drawMotions();\n\t\tthis.drawLinked();\n\t}\n\n\tupdateCurve() {\n\t\tif (this.board.buttons !== 1 || this.selectedEdgeId === null) return;\n\t\tif (this.target) return;\n\t\tthis.onchange();\n\t\tthis.edges[this.selectedEdgeId].curve =\n\t\t\tthis.board.position.getReverseCurvePos(\n\t\t\t\tthis.nodes[this.edges[this.selectedEdgeId].from - 1].x,\n\t\t\t\tthis.nodes[this.edges[this.selectedEdgeId].from - 1].y,\n\t\t\t\tthis.nodes[this.edges[this.selectedEdgeId].to - 1].x,\n\t\t\t\tthis.nodes[this.edges[this.selectedEdgeId].to - 1].y,\n\t\t\t\tthis.board.clientPosition.x,\n\t\t\t\tthis.board.clientPosition.y\n\t\t\t);\n\t}\n\n\tupdateNodes() {\n\t\tthis.nodes = this.nodes.map((node) => this.updateNode(node));\n\t}\n\n\tupdateNode(node) {\n\t\tif (!this.board.buttons || this.board.shift || !this.target)\n\t\t\treturn this.motion ? this.magicFunction(node) : node;\n\n\t\tif (this.target === node.label) {\n\t\t\tthis.onchange();\n\t\t\treturn this.toClientPosition(node);\n\t\t}\n\n\t\treturn this.motion ? this.magicFunction(node) : node;\n\t}\n\n\tupdateMotion() {\n\t\tif (!this.motionSteps.steps?.length) return;\n\n\t\tlet updated = false;\n\t\tthis.motionSteps.steps = this.motionSteps.steps.map((step, index) => {\n\t\t\tif (index > this.motionSteps.step)\n\t\t\t\treturn {\n\t\t\t\t\t...step,\n\t\t\t\t\tstep: 0,\n\t\t\t\t};\n\t\t\tif (step.step >= 1 || updated) return step;\n\t\t\tupdated = true;\n\t\t\treturn {\n\t\t\t\t...step,\n\t\t\t\tstep: (step.step += 1e-2),\n\t\t\t};\n\t\t});\n\t}\n\n\tdrawMotions() {\n\t\tthis.motionSteps.steps.forEach((motion) => this.drawMotion(motion));\n\t}\n\n\tdrawMotion(motion, color) {\n\t\tif (!this.nodes[motion.from - 1] || !this.nodes[motion.to - 1]) return;\n\t\tmotion = this.board.position.ratioLine(\n\t\t\tthis.nodes[motion.from - 1],\n\t\t\tthis.nodes[motion.to - 1],\n\t\t\tmotion.step\n\t\t);\n\t\tthis.board.drawMotionLine(\n\t\t\tmotion.from.x,\n\t\t\tmotion.from.y,\n\t\t\tmotion.to.x,\n\t\t\tmotion.to.y,\n\t\t\tcolor\n\t\t);\n\t}\n\n\taddNode(label, x, y) {\n\t\tconst node = {\n\t\t\tx: x || Math.floor(Math.random() * this.board.canvas.width),\n\t\t\ty: y || Math.floor(Math.random() * this.board.canvas.height),\n\t\t\tlabel,\n\t\t\tmove: 10,\n\t\t};\n\t\tthis.nodes.push(node);\n\t\tthis.onchange();\n\t}\n\n\taddEdge(from, to) {\n\t\tconst newEdge = { from, to, curve: 0 };\n\t\tthis.edges.forEach((edge) => {\n\t\t\tif (edge.from === newEdge.from && edge.to === newEdge.to)\n\t\t\t\tnewEdge.curve = 50 + 50 * Math.random();\n\t\t\tif (edge.from === newEdge.to && edge.to === newEdge.from)\n\t\t\t\tnewEdge.curve = 50 + 50 * Math.random();\n\t\t});\n\t\tthis.edges.push(newEdge);\n\t\tthis.target = null;\n\t\tthis.onchange();\n\t}\n\n\tremoveNode(label) {\n\t\tthis.nodes = this.nodes.filter((e) => e.label !== label);\n\t\tthis.onchange();\n\t\tthis.linkedParts = [];\n\t}\n\n\tremoveEdge(edge) {\n\t\tconst { from, to } = edge;\n\t\tthis.edges = this.edges.filter((e) => e.from !== from || e.to !== to);\n\t\tthis.onchange();\n\t\tthis.linkedParts = [];\n\t}\n\n\tdrawNodes() {\n\t\tthis.nodes.forEach((node) => {\n\t\t\tthis.board.drawNode(\n\t\t\t\tnode.x,\n\t\t\t\tnode.y,\n\t\t\t\tthis.character ? this.alphabet[node.label] : node.label,\n\t\t\t\tthis.target === node.label\n\t\t\t);\n\t\t});\n\t}\n\n\tmagicFunction(e) {\n\t\tif (e.move >= 0)\n\t\t\treturn {\n\t\t\t\t...e,\n\t\t\t\tx: e.x + 0.1,\n\t\t\t\ty: e.y + 0.1,\n\t\t\t\tmove: e.move - 0.1,\n\t\t\t};\n\t\telse if (e.move >= -10)\n\t\t\treturn {\n\t\t\t\t...e,\n\t\t\t\tx: e.x - 0.1,\n\t\t\t\ty: e.y - 0.1,\n\t\t\t\tmove: e.move - 0.1,\n\t\t\t};\n\t\treturn {\n\t\t\t...e,\n\t\t\tmove: 10,\n\t\t};\n\t}\n\n\ttoClientPosition(e) {\n\t\treturn {\n\t\t\t...e,\n\t\t\tx: this.board.clientPosition.x,\n\t\t\ty: this.board.clientPosition.y,\n\t\t};\n\t}\n\n\tdrawEdges() {\n\t\tthis.edges.forEach((edge) => this.drawEdge(edge));\n\t}\n\tdrawLine() {\n\t\tif (!this.board.shift || this.board.buttons !== 1 || !this.target)\n\t\t\treturn;\n\n\t\tconst { x, y } = this.board.clientPosition;\n\t\tthis.board.drawLine(\n\t\t\tthis.nodes[this.target - 1].x,\n\t\t\tthis.nodes[this.target - 1].y,\n\t\t\tx,\n\t\t\ty\n\t\t);\n\t}\n\tcheckAddEdge() {\n\t\tif (!this.target) return;\n\t\tif (!this.board.shift) return;\n\n\t\tconst { x, y } = this.board.clientPosition;\n\t\tthis.nodes.forEach((e) => {\n\t\t\tif (!this.target) return;\n\t\t\tif (e.label === this.target) return;\n\t\t\tif (this.equalPoint(x, e.x) && this.equalPoint(y, e.y)) {\n\t\t\t\tthis.addEdge(this.target, e.label);\n\t\t\t\tthis.target = null;\n\t\t\t}\n\t\t});\n\t}\n\tdrawEdge(edge) {\n\t\tlet posFrom = null;\n\t\tlet posTo = null;\n\n\t\tthis.nodes.forEach((e) => {\n\t\t\tif (e.label == edge.from) posFrom = e;\n\n\t\t\tif (e.label == edge.to) posTo = e;\n\t\t});\n\t\tif (!posFrom || !posTo) return this.removeEdge(edge);\n\n\t\tthis.board.drawCurve(\n\t\t\tposFrom.x,\n\t\t\tposFrom.y,\n\t\t\tposTo.x,\n\t\t\tposTo.y,\n\t\t\tedge.curve\n\t\t);\n\n\t\tif (this.directed)\n\t\t\tthis.board.drawDirected(\n\t\t\t\tposFrom.x,\n\t\t\t\tposFrom.y,\n\t\t\t\tposTo.x,\n\t\t\t\tposTo.y,\n\t\t\t\tedge.curve\n\t\t\t);\n\n\t\tif (this.showDistance)\n\t\t\tthis.board.drawDistance(\n\t\t\t\tposFrom.x,\n\t\t\t\tposFrom.y,\n\t\t\t\tposTo.x,\n\t\t\t\tposTo.y,\n\t\t\t\tedge.curve\n\t\t\t);\n\t}\n\n\texportMatrix() {\n\t\tconst matrix = [];\n\t\tconst row = [];\n\t\tfor (let j = 0; j <= this.nodes.length; j++) row.push(0);\n\t\tfor (let i = 0; i <= this.nodes.length; i++) {\n\t\t\tmatrix.push([...row]);\n\t\t}\n\n\t\tthis.edges.forEach((e) => {\n\t\t\tmatrix[e.from][e.to]++;\n\t\t\tif (!this.directed) matrix[e.to][e.from]++;\n\t\t});\n\n\t\treturn matrix;\n\t}\n\n\tequalPoint(p1, p2) {\n\t\treturn Math.abs(p1 - p2) <= this.board.radius;\n\t}\n\n\tneighbours(from) {\n\t\tconst matrix = this.exportMatrix()[from];\n\t\tconst list = matrix\n\t\t\t.map((e, i) => {\n\t\t\t\tif (e) return i;\n\t\t\t\treturn e;\n\t\t\t})\n\t\t\t.filter((e) => e);\n\t\treturn list;\n\t}\n\n\tdeepFirstSearch(from) {\n\t\tconst marked = [];\n\t\tconst stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\t\tlet steps = [];\n\n\t\tstack.push({ to: from });\n\t\twhile (!stack.empty()) {\n\t\t\tconst top = stack.top();\n\t\t\tstack.pop();\n\n\t\t\tif (marked[top.to]) continue;\n\n\t\t\tmarked[top.to] = true;\n\t\t\tsteps.push(top);\n\t\t\tconst neighbours = this.neighbours(top.to);\n\n\t\t\tneighbours.forEach((node) => {\n\t\t\t\tstack.push({ from: top.to, to: node });\n\t\t\t});\n\t\t}\n\n\t\tsteps = {\n\t\t\tstep: 0,\n\t\t\tsteps: steps\n\t\t\t\t.filter((step) => step.from)\n\t\t\t\t.map((step) => ({\n\t\t\t\t\t...step,\n\t\t\t\t\tstep: 0,\n\t\t\t\t})),\n\t\t};\n\n\t\tthis.motionStart(steps);\n\t\treturn steps;\n\t}\n\n\tbreadthFirstSearch(from) {\n\t\tconst marked = [];\n\t\tconst queue = new _Queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\t\tlet steps = [];\n\n\t\tqueue.enQueue({ to: from });\n\n\t\twhile (!queue.empty()) {\n\t\t\tconst front = queue.deQueue();\n\t\t\tif (marked[front.to]) continue;\n\n\t\t\tmarked[front.to] = true;\n\t\t\tsteps.push(front);\n\t\t\tconst neighbours = this.neighbours(front.to);\n\t\t\tneighbours.forEach((node) => {\n\t\t\t\tqueue.enQueue({ from: front.to, to: node });\n\t\t\t});\n\t\t}\n\n\t\tsteps = {\n\t\t\tstep: 0,\n\t\t\tsteps: steps\n\t\t\t\t.filter((node) => node.from)\n\t\t\t\t.map((node) => ({\n\t\t\t\t\t...node,\n\t\t\t\t\tstep: 0,\n\t\t\t\t})),\n\t\t};\n\t\tthis.motionStart(steps);\n\t\treturn steps;\n\t}\n\n\tdrawLinked() {\n\t\tif (!this.linkedParts.length) return;\n\n\t\tthis.linkedParts.forEach((linked) => {\n\t\t\tif (linked.length === 1) return;\n\t\t\tfor (let i = 0; i < linked.length; i++)\n\t\t\t\tfor (let j = 0; j < linked.length; j++) {\n\t\t\t\t\tif (i === j) continue;\n\t\t\t\t\tif (!this.neighbours(linked[i]).includes(linked[j]))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tthis.drawMotion(\n\t\t\t\t\t\t{ from: linked[i], to: linked[j], step: 1 },\n\t\t\t\t\t\t\"red\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t});\n\t}\n\n\ttarjanStop() {\n\t\tthis.linkedParts = [];\n\t\tthis.onchange();\n\t}\n\n\ttarjanStart() {\n\t\tthis.linkedParts = this.tarjan();\n\t\tthis.onchange();\n\t}\n\n\ttarjan() {\n\t\tconst tarjan = new _Tarjan__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n\t\treturn tarjan.tarjan();\n\t}\n\n\tappendTo(selector) {\n\t\tthis.board.appendTo(selector);\n\t}\n\n\tmotionStart(motionSteps) {\n\t\tthis.motionSteps = motionSteps;\n\t\tthis.onchange();\n\t}\n\n\tmotionStop() {\n\t\tthis.motionSteps.step = 0;\n\t\tthis.motionSteps.steps = [];\n\t\tthis.onchange();\n\t}\n\n\tnextStep() {\n\t\tif (this.motionSteps.step === this.motionSteps.step - 1)\n\t\t\treturn this.motionSteps.step;\n\t\tthis.motionSteps.step++;\n\t\tthis.onchange();\n\t\treturn this.motionSteps.step;\n\t}\n\tprevStep() {\n\t\tif (this.motionSteps.step === 0) return this.motionSteps.step;\n\t\tthis.motionSteps.step--;\n\t\tthis.onchange();\n\t\treturn this.motionSteps.step;\n\t}\n\n\t// GETTER\n\tgetNodes() {\n\t\treturn this.nodes.map((node) => ({\n\t\t\t...this.edges,\n\t\t\tlabel: this.character ? this.alphabet[node.label] : node.label,\n\t\t}));\n\t}\n\tgetEdges() {\n\t\treturn this.edges.map((edge) => ({\n\t\t\t...edge,\n\t\t\tfrom: this.character ? this.alphabet[edge.from] : edge.from,\n\t\t\tto: this.character ? this.alphabet[edge.to] : edge.label,\n\t\t}));\n\t}\n\n\t// SETTER\n\tsetDirected(directed) {\n\t\tthis.directed = directed;\n\t\tthis.onchange();\n\t}\n\tsetShowGrid(showGrid) {\n\t\tthis.showGrid = showGrid;\n\t\tthis.onchange();\n\t}\n\tsetShowDistance(showDistance) {\n\t\tthis.showDistance = showDistance;\n\t\tthis.onchange();\n\t}\n\n\tsetRadius(radius) {\n\t\tthis.board.radius = radius;\n\t\tthis.onchange();\n\t}\n\tsetMotion(motion) {\n\t\tthis.motion = motion;\n\t\tthis.onchange();\n\t}\n\tsetCharacter(character) {\n\t\tthis.character = character;\n\t\tthis.onchange();\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Graph);\n\n\n//# sourceURL=webpack://graph-board/./src/Graph.js?");

/***/ }),

/***/ "./src/Position.js":
/*!*************************!*\
  !*** ./src/Position.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Position)\n/* harmony export */ });\nclass Position {\n\tconstructor(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tgetDistance(pos1, pos2) {\n\t\treturn Math.sqrt(\n\t\t\tMath.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2)\n\t\t);\n\t}\n\tgetCurvePos(x1, y1, x2, y2, distance) {\n\t\tconst middle = this.getMiddle(x1, y1, x2, y2);\n\t\tconst angle = this.getAngle(x1, y1, x2, y2);\n\t\treturn {\n\t\t\tx: middle.x + distance * Math.cos(angle + Math.PI / 2),\n\t\t\ty: middle.y + distance * Math.sin(angle + Math.PI / 2),\n\t\t};\n\t}\n\tgetReverseCurvePos(x1, y1, x2, y2, px, py) {\n\t\tconst middle = this.getMiddle(x1, y1, x2, y2);\n\t\tconst angle = this.getAngle(x1, y1, x2, y2);\n\n\t\treturn (\n\t\t\t(px - middle.x) / Math.cos(angle + Math.PI / 2) +\n\t\t\t(py - middle.y) / Math.sin(angle + Math.PI / 2)\n\t\t);\n\t}\n\tgetMiddle(x1, y1, x2, y2) {\n\t\treturn {\n\t\t\tx: (x1 + x2) / 2,\n\t\t\ty: (y1 + y2) / 2,\n\t\t};\n\t}\n\tgetAngle(x1, y1, x2, y2) {\n\t\treturn Math.atan2(y1 - y2, x1 - x2);\n\t}\n\tratioLine(pos1, pos2, ratio) {\n\t\tratio = 1 - ratio;\n\t\tconst distance = this.getDistance(pos1, pos2);\n\t\tconst miss = distance * ratio;\n\t\tconst angle = this.getAngle(pos1.x, pos1.y, pos2.x, pos2.y);\n\t\treturn {\n\t\t\tfrom: pos1,\n\t\t\tto: {\n\t\t\t\tx: pos2.x + miss * Math.cos(angle),\n\t\t\t\ty: pos2.y + miss * Math.sin(angle),\n\t\t\t},\n\t\t};\n\t}\n}\n\n\n//# sourceURL=webpack://graph-board/./src/Position.js?");

/***/ }),

/***/ "./src/Queue.js":
/*!**********************!*\
  !*** ./src/Queue.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Queue)\n/* harmony export */ });\nclass Queue {\n\tconstructor() {\n\t\tthis.__data__ = [];\n\t}\n\tdeQueue() {\n\t\treturn this.__data__.shift();\n\t}\n\tenQueue(x) {\n\t\tthis.__data__.push(x);\n\t}\n\tempty() {\n\t\treturn !this.__data__.length;\n\t}\n}\n\n\n//# sourceURL=webpack://graph-board/./src/Queue.js?");

/***/ }),

/***/ "./src/Stack.js":
/*!**********************!*\
  !*** ./src/Stack.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Stack)\n/* harmony export */ });\nclass Stack {\n\t// initial stack\n\tconstructor(__data__) {\n\t\tthis.__data__ = [];\n\t}\n\t// get top element of stack\n\ttop() {\n\t\treturn this.__data__[this.__data__.length - 1];\n\t}\n\t// check empty stack\n\tempty() {\n\t\treturn this.__data__.length === 0;\n\t}\n\t// pop top element of stack\n\tpop() {\n\t\treturn this.__data__.pop();\n\t}\n\t// push element to top stack\n\tpush(x) {\n\t\tthis.__data__.push(x);\n\t}\n\tincludes(x) {\n\t\treturn this.__data__.indexOf(x) !== -1;\n\t}\n}\n\n\n//# sourceURL=webpack://graph-board/./src/Stack.js?");

/***/ }),

/***/ "./src/Tarjan.js":
/*!***********************!*\
  !*** ./src/Tarjan.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tarjan)\n/* harmony export */ });\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stack */ \"./src/Stack.js\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Graph */ \"./src/Graph.js\");\n\n\n\nclass Tarjan {\n\t/**\n\t * @param {Graph} graph\n\t */\n\tconstructor(graph) {\n\t\tthis.stack = new _Stack__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\t\tthis.step = 1;\n\t\tthis.num = [];\n\t\tthis.minNum = [];\n\t\tthis.linkedParts = [];\n\t\tthis.graph = graph;\n\t}\n\n\ttarjan() {\n\t\tthis.graph.nodes.forEach((node) => {\n\t\t\tif (this.num[node.label]) return;\n\t\t\tthis.__tarjan(node.label);\n\t\t});\n\t\treturn this.linkedParts;\n\t}\n\t__tarjan(from) {\n\t\tif (this.num[from]) return this.linkedParts;\n\n\t\tthis.num[from] = this.step;\n\t\tthis.minNum[from] = this.step;\n\t\tthis.step++;\n\t\tthis.stack.push(from);\n\n\t\tconst neighbours = this.graph.neighbours(from);\n\n\t\tneighbours.forEach((neighbour) => {\n\t\t\tif (this.stack.includes(neighbour))\n\t\t\t\treturn (this.minNum[from] = Math.min(\n\t\t\t\t\tthis.num[neighbour],\n\t\t\t\t\tthis.minNum[from]\n\t\t\t\t));\n\n\t\t\tthis.__tarjan(neighbour);\n\t\t\tthis.minNum[from] = Math.min(\n\t\t\t\tthis.minNum[neighbour],\n\t\t\t\tthis.minNum[from]\n\t\t\t);\n\t\t});\n\n\t\tif (this.num[from] !== this.minNum[from]) return this.linkedParts;\n\n\t\tconst linked = [];\n\t\twhile (this.stack.top() !== from) linked.push(this.stack.pop());\n\n\t\tlinked.push(this.stack.pop());\n\n\t\tthis.linkedParts.push(linked);\n\n\t\treturn this.linkedParts;\n\t}\n}\n\n\n//# sourceURL=webpack://graph-board/./src/Tarjan.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph */ \"./src/Graph.js\");\n\nwindow.Graph = _Graph__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\n\n//# sourceURL=webpack://graph-board/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;